# 函数指针与回调函数

## 函数指针

> 函数指针最常见的两个用途是：1）转换表（jump table）；2）作为参数传递给另一个函数



### 函数指针的定义

对函数指针执行间接访问前必须将其初始化为指向某个函数：

```C
int f(int);
int (*pf)(int) = &f;  //此声明创建了函数指针pf，并将其初始化为指向函数f
```

在函数指针初始化之前具有被指向的函数的原型很重要，否则编译器无法检查f的类型是否与pf所指向的一致。



### 函数指针的调用方式

```C
int ans;
ans = f(25);        //方式一：使用函数名调用函数f
ans = (*pf)(25);    //方式二：对pf进行间接访问操作
ans = pf(25);       //方式三：
```

* 方式一：使用函数名调用函数的执行过程是先将函数名转化为函数指针（该指针指定函数在内存中的位置），然后调用**函数调用操作符**调用该函数，执行开始于这个内存地址的代码。
* 方式二：`*pf`将函数指针转化为一个函数名，编译器在执行**函数调用操作符**之前又会将它转为函数指针。
* 方式三：



## 回调函数

【问题背景】

某个函数功能为：在单链表中查找一个值，它的参数是一个指向链表第一个节点（头节点）的指针，以及需要查找的值。

```C
Node * search_list(Node* node,int const value)
{
    while(node != NULL)
    {
        if(node->next == value)
            break;
        node = node ->link;
    }
    return node;
}
```

该函数只适用于整数链表，若在字符串链表中就得重写节点类型（函数第二个参数）以及节点值的比较方法（函数绝大多数代码和上面函数相同）。对于这种情况，我们需要找到一种方式，使函数与类型无关。需要做如下改进：

1. 改变比较的执行方式：使其对任何类型的值都能进行比较
2. 改变节点类型声明：

实现方法：

1. 使用函数指针指向一个实现比较功能的函数，然后将此函数指针作为参数传递给查找函数
2. 传递给查找函数的是一个指向值的指针而不是值本身。给予函数一个**`void*`**类型（**一个指向未知类型的指针**）的形参用来接受待比较的参数。（这个修改使字符串和数组对象也可以适用，字符串和数组无法作为参数表传递给函数，但指向他们的指针可以）

```c
Node* search_list(Node* node,void* target);
```



使用这种技巧的函数称为**回调函数（callback function）**，因为用户把一个函数指针作为参数传递给其他函数，后者将“回调”用户的函数。



查找函数向比较函数传递两个指向需要进行比较的值的指针，并检查比较函数的返回值（例如：返回0表示相等，非0表示不相等）。

现在查找函数就不执行实际比较，实现了与类型无关。

为每种类型编写一个比较函数就允许单个查找函数作用于所有类型的链表了。

```C
/*类型无关的链表查找*/
Node* search_list(Node* node,void const *value,int (*compare)(void const *,void const *))
{
    while(node != NULL)
    {
        if(compare(&node->next,value) == 0)
            break;
        node = node -> link;
    }
    return node;
}
```

